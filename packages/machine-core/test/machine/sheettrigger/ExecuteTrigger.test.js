/********************************************************************************
 * Copyright (c) 2020 Cedalo AG
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 ********************************************************************************/
const {
	ContinuouslyTrigger,
	ExecuteTrigger,
	Machine,
	Message,
	NeverTrigger,
	StreamSheet2,
	TriggerFactory
} = require('../../..');
const { createCellAt, wait } = require('../../utils');

const addOutboxMessage = (machine, message) => {
	message = message || new Message({ outbox: true });
	machine.outbox.put(message);
	return message.id;
};

const setup = ({ switched = false } = {}) => {
	const machine = new Machine();
	const s1 = new StreamSheet2({ name: 'S1' });
	const s2 = new StreamSheet2({ name: 'S2' });
	s1.trigger = switched ? new ExecuteTrigger() : new ContinuouslyTrigger();
	s2.trigger = switched ? new ContinuouslyTrigger() : new ExecuteTrigger();
	machine.removeAllStreamSheets();
	machine.addStreamSheet(s1);
	machine.addStreamSheet(s2);
	machine.cycletime = 50;
	return { machine, s1, s2 };
};

describe('ExecuteTrigger', () => {
	describe('general behaviour', () => {
		it('should calculate sheet if called by another sheet on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
		});
		it('should calculate sheet if called by another sheet on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
		});
		it('should calculate sheet if called by another sheet on manual steps if machine is paused', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
		});
		it('should repeat execute as often as specified by repetitions parameter on manual step', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(5);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(13);
		});
		it('should repeat execute as often as specified by repetitions parameter on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(13);
		});
		it('should pause calling sheet if execute with "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBeGreaterThan(5);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(s2.sheet.cellAt('A4').value).toBe(false);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
			expect(s2.sheet.cellAt('A4').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(9);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on manual steps switched sheet order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(9);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run and switched order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should execute endlessly in "repeat until..." on manual step', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(5);
		});
		it('should execute endlessly in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBeGreaterThan(2);
		});
		it('should stop repetitions of execute as soon as return() is called with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('A2').value).toBe(15);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		it('should stop repetitions of execute as soon as return() is called with machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		it('should stop repetitions of execute as soon as return() is called in "repeat until..." with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('A2').value).toBe(15);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		it('should stop repetitions of execute as soon as return() is called in "repeat until..." with machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A4', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A4').value).toBe(true);
		});
		test('chain of execution with several sheets on machine run', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet2();
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(9);
			expect(s3.sheet.cellAt('C2').value).toBe(true);
			expect(s3.sheet.cellAt('C3').value).toBe(9);
		});
		test('chain of execution with several sheets on manual steps', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet2();
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(1);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(2);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(3);
			expect(s3.sheet.cellAt('C3').value).toBe(3);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(4);
			expect(s3.sheet.cellAt('C3').value).toBe(4);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(6);
			expect(s3.sheet.cellAt('C3').value).toBe(6);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
		});
	});
	describe('updating trigger', () => {
		it('should stop repeat "repeat until..." if corresponding setting is disabled', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger.update({ repeat: 'once' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it('should continue process sheet if new trigger is set', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new ExecuteTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThanOrEqual(3);
			await machine.stop();
		});
		it('should stop process sheet if new trigger is NONE', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new NeverTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.stop();
		});
		it('should stop "repeat until..." if new trigger is set without "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger();
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it('should keep "repeat until..." if new trigger is set with same', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
		it('should not resume on "repeat until.." if new trigger is set and sheet is paused by function', async () => {
			const { machine, s1, s2 } = setup();
			const newTrigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'pause()' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			s2.trigger = newTrigger;
			await wait(20);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
	});
	describe.skip('Message processing', () => {
		it.skip('should use passed message', async () => {
			const { machine, s1, s2 } = setup();
			const counts = { attached: 0, detached: 0 };
			const messageId = addOutboxMessage(machine);
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.on('message_attached', () => {
				counts.attached += 1;
			});
			s2.on('message_detached', () => {
				counts.detached += 1;
			});
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(counts.attached).toBe(1);
			expect(counts.detached).toBe(1);
			await machine.step();
			await machine.step();
			expect(counts.attached).toBe(3);
			expect(counts.detached).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
		});
		it.skip('should use passed message before using inbox ones', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(3);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
			// a processed message is removed with next step
			await machine.step();
			expect(s2.inbox.size).toBe(1);
		});
		it.skip('should use passed message before using inbox ones on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(3);
			await machine.start();
			await wait(5);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			// 3 because: (=>1) -> start(=>2) -> pause -> start(=>3)
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(7);
			// a processed message is removed with next step
			await machine.start();
			await wait(100);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
		});
		it.skip('should consume a message on each execute-repetition', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(5);
			// last message is consumed by still in inbox due to client...
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(13);
		});
		it.skip('should consume a message on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await wait(10);
			await machine.pause();
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(7);
			await machine.start();
			await wait(100);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('A2').value).toBe(16);
		});
		it.skip('should consume loop-element on each repetition', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(4);
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(7);
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(10);
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
		});
		it.skip('should consume loop-element on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await wait(10);
			await machine.pause();
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			// 3 because: (=>1) -> start(=>2) -> pause -> start(=>3)
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(7);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(10);
			await machine.stop();
		});
		it.skip('should use passed message with loop element before next in inbox', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(3);
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(7);
			// increase repetitions value => inbox messages must be used:
			createCellAt('A2', { formula: `execute("S2", 5, "out:${messageId}")` }, s1.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('A2').value).toBe(12);
		});
		it.skip('should use passed message with loop element before next in inbox on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger();
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(3);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			// 3 because: (=>1) -> start(=>2) -> pause -> start(=>3)
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(5);
			// increase repetitions value => inbox messages must be used:
			createCellAt('A2', { formula: `execute("S2", 5, "out:${messageId}")` }, s1.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(10);
			await machine.stop();
		});
		it.skip('should reuse passed message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			const counts = { attached: 0, detached: 0 };
			let messageId = addOutboxMessage(machine);
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.on('message_attached', () => {
				counts.attached += 1;
			});
			s2.on('message_detached', () => {
				counts.detached += 1;
			});
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A3', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(counts.attached).toBe(1);
			expect(counts.detached).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(s2.sheet.cellAt('A3').value).toBe(false);
			await machine.step();
			expect(counts.attached).toBe(1);
			expect(counts.detached).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			messageId = addOutboxMessage(machine);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(counts.attached).toBe(2);
			expect(counts.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			// same with running machine:
			counts.attached = 0;
			counts.detached = 0;
			messageId = addOutboxMessage(machine);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			await machine.start();
			await wait(110);
			await machine.stop();
			expect(counts.attached).toBe(1);
			expect(counts.detached).toBe(2); // <-- 2 because we detach old message
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBeGreaterThanOrEqual(9);
		});
		it.skip('should reuse same message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A3', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(s2.sheet.cellAt('A3').value).toBe(false);
			await machine.step();
			expect(s2.inbox.size).toBe(3); // <-- detach in next step
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1); // <-- keep last message
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(9);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
		});
		it.skip('should reuse same message on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A3', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(1);
			expect(s2.sheet.cellAt('A3').value).toBe(false);
			await machine.start();
			await wait(10);
			await machine.pause();
			// const s2a2 = s2.sheet.cellAt('A2').value;
			expect(s2.inbox.size).toBe(2);
			// expect(s2a2).toBeGreaterThan(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			// expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBeGreaterThanOrEqual(6);
			// expect(s2.sheet.cellAt('A3').value).toBe(true);
			// await machine.start();
			// await wait(130);
			// await machine.pause();
			// expect(s2.inbox.size).toBe(1);
			// expect(s1.sheet.cellAt('A1').value).toBe(3);
			// expect(s1.sheet.cellAt('A3').value).toBe(3);
			// expect(s2.sheet.cellAt('A2').value).toBeGreaterThanOrEqual(6);
			// await machine.stop();
		});
		it.skip('should use next message on each execute-repetition but reuse last on "repeat until..." until return()', async () => {
			expect(false).toBe(true);
		});
		it.skip('should reuse same loop-element on "repeat until..." until return()', async () => {
			expect(false).toBe(true);
		});
		it.skip('should use next loop-element on each execute-repetition but reuse last on "repeat until..." until return()', async () => {
			expect(false).toBe(true);
		});
		it.skip('should reuse same message on "repeat until..."', async () => {
			expect(false).toBe(true);
		});
		it.skip('should reuse same loop element on "repeat until..."', async () => {
			expect(false).toBe(true);
		});
		it.skip('should use next message on "repeat until..." if return was called', async () => {
			expect(false).toBe(true);
		});
		it.skip('should use next loop element on "repeat until..." if return was called', async () => {
			expect(false).toBe(true);
		});
		it.skip('should repeat calculation as often as specified by repeat parameter using same message', async () => {
			expect(false).toBe(true);
		});
		it.skip('should repeat calculation as often as specified by repeat parameter using same loop element', async () => {
			expect(false).toBe(true);
		});
		test.skip('calling sheet waits at same message until execute() returns', () => {
			expect(false).toBe(true);
		});
		test.skip('calling sheet waits at same loop-element until execute() returns', () => {
			expect(false).toBe(true);
		});
	});
	describe('executesteps counter', () => {
		it('should count each repetition in executesteps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(30);
			await machine.pause();
			expect(s2.stats.steps).toBe(1);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			await machine.stop();
		});
		it('should restart repetition count on each execution', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should restart repetition count on each repeat in "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",5)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B4', { formula: 'if(mod(B2,2)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			// executesteps count is bound by return each 2 calcs
			expect(s2.stats.executesteps).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B4').value).toBe(true);
		});
		it('should increase step counter on each execution call', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s1.stats.steps).toBe(3);
			expect(s2.stats.steps).toBe(3);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should not increase step counter on each execution call on "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			expect(s2.stats.steps).toBe(1);
			expect(s2.stats.repeatsteps).toBeGreaterThan(2);
			expect(s2.stats.executesteps).toBe(1);
			await machine.stop();
		});
	});
	describe('serialize', () => {
		it('should be possible to save trigger settings to JSON', () => {
			let json = new ExecuteTrigger().toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(json.repeat).toBe('once');
			json = new ExecuteTrigger({ repeat: 'endless' }).toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(json.repeat).toBe('endless');
		});
		it('should be possible to restore trigger from JSON', () => {
			let trigger = TriggerFactory.create(new ExecuteTrigger().toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(trigger.isEndless).toBe(false);
			trigger = TriggerFactory.create(new ExecuteTrigger({ repeat: 'endless' }).toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(trigger.isEndless).toBe(true);
		});
	});
});
