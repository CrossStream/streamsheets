/********************************************************************************
 * Copyright (c) 2020 Cedalo AG
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 ********************************************************************************/
const {
	ContinuousTrigger,
	ExecuteTrigger,
	Machine,
	Message,
	NeverTrigger,
	StreamSheet,
	TriggerFactory
} = require('../../..');
const { createCellAt, expectValue, monitorMachine, monitorStreamSheet, wait } = require('../../utils');

const addOutboxMessage = (machine, message) => {
	message = message || new Message({ outbox: true });
	machine.outbox.put(message);
	return message.id;
};

const setup = ({ switched = false } = {}) => {
	const machine = new Machine();
	const s1 = new StreamSheet({ name: 'S1' });
	const s2 = new StreamSheet({ name: 'S2' });
	s1.trigger = switched ? new ExecuteTrigger() : new ContinuousTrigger();
	s2.trigger = switched ? new ContinuousTrigger() : new ExecuteTrigger();
	machine.removeAllStreamSheets();
	machine.addStreamSheet(s1);
	machine.addStreamSheet(s2);
	machine.cycletime = 50;
	return { machine, s1, s2 };
};

describe('ExecuteTrigger', () => {
	describe.skip('general behaviour', () => {
		it('should calculate sheet if called by another sheet on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should calculate sheet if called by another sheet on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(130);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should pause calling sheet until executed sheet returns on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'pause(0.1)' }, s2.sheet);
			await machine.start();
			await wait(400);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B1').value).toBeGreaterThanOrEqual(4);
		})
		it('should calculate sheet if called by another sheet on manual steps if machine is paused', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should repeat execute as often as specified by repetitions parameter on manual step', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(5);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(13);
		});
		it('should repeat execute as often as specified by repetitions parameter on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(130);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(13);
		});
		it('should pause calling sheet if execute with "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(5);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(3);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(9);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on manual steps switched sheet order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(3);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(9);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run and switched order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should execute endlessly in "repeat until..." on manual step', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(5);
		});
		it('should execute endlessly in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
		});
		it('should stop repetitions of execute as soon as return() is called with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			createCellAt('B4', { formula: 'B4+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(11);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(8);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(21);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(14);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(51);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(34);
		});
		it('should stop repetitions of execute as soon as return() is called with machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			createCellAt('B4', { formula: 'B4+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(21);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(14);
		});
		it('should stop repetitions of execute as soon as return() is called in "repeat until..." with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",2)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			createCellAt('B4', { formula: 'B4+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			expect(s2.sheet.cellAt('B4').value).toBe(2);
			await machine.step(); // will resume and directly repeat execute again
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
			// NOTE: B§ contains true because its value of step and not from repeat which would have been false!!
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(3);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(5);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			expect(s2.sheet.cellAt('B4').value).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(7);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			expect(s2.sheet.cellAt('B4').value).toBe(5);
		});
		it('should stop repetitions of execute as soon as return() is called in "repeat until..." with machine run', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",2)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			createCellAt('B4', { formula: 'B4+1' }, s2.sheet);
			await machine.start();
			await machineMonitor.hasPassedStep(2);
			await wait(30);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(12);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(8);
		});
		test('chain of execution with several sheets on machine run', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet();
			const monitorS2 = monitorStreamSheet(s2);
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(8);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(9);
			expect(s3.sheet.cellAt('C2').value).toBe(true);
			expect(s3.sheet.cellAt('C3').value).toBe(9);
		});
		test('chain of execution with several sheets on manual steps', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet();
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(1);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step(); // finish S2 which resumes S3
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(2);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(3);
			expect(s3.sheet.cellAt('C3').value).toBe(3);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(4);
			expect(s3.sheet.cellAt('C3').value).toBe(4);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(6);
			expect(s3.sheet.cellAt('C3').value).toBe(6);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
		});
		test('chain of execution on manual steps', async () => {
			// setup: 3 streamsheets in following order: S1 -> executes -> S2 -> executes -> S3
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet({ name: 'S3' });
			machine.addStreamSheet(s3);
			s1.trigger.update({ repeat: 'endless' });
			s1.sheet.load({
				cells: { A1: { formula: 'A1+1' }, A2: { formula: 'execute("S2", 2)' }, A3: { formula: 'A3+1' } }
			});
			s2.sheet.load({
				cells: { B1: { formula: 'B1+1' }, B2: { formula: 'execute("S3", 3)' }, B3: { formula: 'B3+1' } }
			});
			s3.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE });
			s3.sheet.load({ cells: { C1: { formula: 'C1+1' } } });
	
			// initial values:
			expect(s1.sheet.cellAt('A1').value).toBe(1);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s3.sheet.cellAt('C1').value).toBe(1);
	
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s2.stats.executesteps).toBe(2);
			expect(s3.sheet.cellAt('C1').value).toBe(7);
			expect(s3.stats.executesteps).toBe(3);
			
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(5);
			expect(s2.stats.executesteps).toBe(2);
			expect(s3.sheet.cellAt('C1').value).toBe(13);
			expect(s3.stats.executesteps).toBe(3);
	
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(7);
			expect(s2.stats.executesteps).toBe(2);
			expect(s3.sheet.cellAt('C1').value).toBe(19);
			expect(s3.stats.executesteps).toBe(3);
		});
		test('DL-1528, derived from ampelbug2', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START, repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(B1>=10,return(),false)' }, s2.sheet);
			await machine.start();
			// wait until s2 got called 5 times
			await monitorS2.hasPassedStep(5);
			// s1 is endless and never returns, so stay at 1
			expect(s1.stats.steps).toBe(1);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(14);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
		});
	});
	describe.skip('updating trigger', () => {
		it('should stop repeat "repeat until..." if corresponding setting is disabled', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger.update({ repeat: 'once' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it('should continue process sheet if new trigger is set', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new ExecuteTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThanOrEqual(3);
			await machine.stop();
		});
		it('should stop process sheet if new trigger is NONE', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new NeverTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.stop();
		});
		it('should stop "repeat until..." if new trigger is set without "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger();
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it('should keep "repeat until..." if new trigger is set with same setting', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await machineMonitor.nextSteps(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			// await wait(20);
			await machineMonitor.nextSteps(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(s2b2);
			await machineMonitor.nextSteps(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
		// it('should resume on "repeat until.." if new trigger is set and sheet is paused by function', async () => {
		it('should have no effect if new trigger has same settings in "repeat until..." mode and sheet is paused by function', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			const newTrigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'pause()' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await machineMonitor.nextSteps(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			s2.trigger = newTrigger;
			await machineMonitor.nextSteps(3);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
	});
	describe.skip('message processing', () => {
		it('should reuse passed message on manual steps if its the same', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(1);
			await machine.step();
			await machine.step();
			expect(monitorS2.messages.attached).toBe(1);
			// although message is reused it is processed & detached
			expect(monitorS2.messages.detached).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
		});
		it('should reuse passed message on machine run if its same', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(monitorS2.messages.attached).toBe(1);
			// although message is reused it is processed & detached
			expect(monitorS2.messages.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
		});
		it('should use passed message on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId1 = addOutboxMessage(machine);
			const messageId2 = addOutboxMessage(machine);
			const messageId3 = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId1}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(1);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId2}")` }, s1.sheet);
			await machine.step();
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId3}")` }, s1.sheet);
			await machine.step();
			expect(monitorS2.messages.attached).toBe(3);
			expect(monitorS2.messages.detached).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			expect(s2.inbox.size).toBe(1);
		});
		it('should use passed message on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId1 = addOutboxMessage(machine);
			const messageId2 = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId1}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId2}")` }, s1.sheet);
			await wait(70);
			await machine.stop();
			expect(monitorS2.messages.attached).toBe(2);
			expect(monitorS2.messages.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
		});
		it('should use passed message before using inbox ones', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(2);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			// 3x repetitions => should be 1 message left...
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.step();
			// 3x repetitions => should be 1 message left...
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
		});
		it('should use passed message before using inbox ones on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			const monitorS1 = monitorStreamSheet(s1);
			const machineMonitor = monitorMachine(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(20);
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s1.stats.steps).toBe(1);
			// outbox message is added to inbox of S2
			expect(s2.inbox.size).toBe(3);
			expect(s2.machine.outbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.start();
			await monitorS1.hasPassedStep(2);
			await machine.pause();
			expect(s1.stats.steps).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s1.stats.steps).toBe(3);
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.start();
			await machineMonitor.nextSteps(2);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
		});
		it('should consume a message on each execute-repetition on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			// last message is consumed but still in inbox due to client...
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
		});
		it('should consume a message on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s1.stats.steps).toBe(2);
			expect(s2.stats.executesteps).toBe(3);
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(3);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(16);
		});
		it('should consume loop-element on each repetition on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
		});
		it('should consume loop-element on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should use passed message with loop element before next in inbox', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(3);
			await machine.step();
			// inbox messages never used, because we pass message on each repetition 
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			createCellAt('A2', { formula: `execute("S2", 5)`}, s1.sheet); // , "out:${messageId}")` }, s1.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
		});
		it('should use passed message with loop element before next in inbox on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			// outbox message is passed to inbox of S2
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			createCellAt('A2', { formula: `execute("S2", 5)` }, s1.sheet); // , "out:${messageId}")` }, s1.sheet);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.stop();
		});
		it('should reuse passed message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			let messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.step();
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			messageId = addOutboxMessage(machine);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(monitorS2.messages.attached).toBe(2);
			expect(monitorS2.messages.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
		});
		it('should reuse passed message on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			const monitorS2 = monitorStreamSheet(s2);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,2)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(4);
			await machine.stop();
			expect(s2.sheet.cellAt('B1').value).toBe(8);
			expect(monitorS2.messages.attached).toBe(1); // <-- executed 3x, but we always pass same message
			expect(monitorS2.messages.detached).toBe(4); // <-- 3 because we detach old message
			expect(s2.sheet.cellAt('B1').value).toBe(8);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
		});
		it('should reuse same message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuousTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A3', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(s2.sheet.cellAt('A3').value).toBe(false);
			await machine.step();
			expect(s2.inbox.size).toBe(3); // <-- detach in next step
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1); // <-- keep last message
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(9);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
		});
		it('should reuse same message on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.start();
			await monitorS2.hasPassedStep(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.hasPassedStep(3);
			await machine.pause();
			expect(s2.inbox.size).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			await machine.stop();
		});
		it('should reuse same loop-element on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 1)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.trigger.update({ repeat: 'endless' });
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			// we stay at last message and loop element
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(9);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
		});
		it('should reuse same loop-element on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await machine.pause();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 1)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await monitorS2.hasPassedStep(2);
			await machine.pause();
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.hasPassedStep(4);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.hasPassedStep(6);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.hasPassedStep(8);
			await machine.pause();
			// we stay at last message and loop element
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(9);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.stop();
		});
		it('should resume calling sheet and stop "repeat until..." if execute() cell is replaced', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			// replace execute cell
			createCellAt('A2', { formula: 'A2+1' }, s1.sheet);
			await machine.step();
			expect(s1.stats.steps).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.stats.steps).toBe(5);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(5);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
		});
		it('should resume calling sheet and stop "repeat until..." if execute() cell is replaced on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS1 = monitorStreamSheet(s1);
			// const machineMonitor = monitorMachine(machine);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBeGreaterThanOrEqual(3);
			// replace execute cell
			createCellAt('A2', { formula: 'A2+1' }, s1.sheet);
			const s2b1 = s2.sheet.cellAt('B1').value;
			await machine.start();
			await monitorS1.hasPassedStep(4);
			await machine.pause();
			expect(s1.stats.steps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(s2b1);
			await machine.stop();
		});
		test('calling sheet waits at same message on "repeat until..." until execute() returns', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			await machine.step();
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.step();
			await machine.step();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.step();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			// stay at last message:
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
		});
		test('calling sheet waits at same message on "repeat until..." until execute() returns on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			await machine.start();
			await machine.pause();
			// setup sheets
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(1);
			await machine.pause();
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.hasPassedStep(2);
			await machine.pause();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.start();
			await monitorS2.hasPassedStep(3);
			await machine.pause();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			// stay at last message:
			await machine.start();
			await monitorS2.hasPassedStep(5);
			await machine.stop();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
		});
		test('calling sheet waits at same loop-element on "repeat until..." until execute() returns', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s1.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			await machine.step();
			expect(s1.inbox.size).toBe(3);
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			await machine.step();
			await machine.step();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.step();
			await machine.step();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			// stay at last message:
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(17);
		});
		test('calling sheet waits at same loop-element on "repeat until..." until execute() returns on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			await machine.start();
			await machine.pause();
			// setup sheets
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s1.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(1);
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.hasPassedStep(2);
			await machine.pause();
			expect(s1.inbox.size).toBe(3);
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.start();
			await monitorS2.hasPassedStep(3);
			await machine.pause();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			await machine.start();
			await monitorS2.hasPassedStep(4);
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			// stay at last message:
			await machine.start();
			await monitorS2.hasPassedStep(6);
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
		});
	});
	describe.skip('DL-1114 based tests', () => {
		test('chained execution with passed data', async () => {
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet();
			machine.addStreamSheet(s3);
			s3.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE });
			s1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START });
			s1.sheet.loadCells({
				A1: { formula: 'A1+1' },
				A2: 'hello', B2: 'world',
				A3: { formula: 'execute("S2",2,array(A2,B2))' },
				A4: { formula: 'A4+1' }
			});
			s2.sheet.loadCells({ B1: { formula: 'B1+1' }, B2: { formula: 'execute("S3", 3)' } });
			s3.sheet.loadCells({ C1: { formula: 'C1+1' } });
			await machine.start();
			await wait(30);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(true);
			expect(s1.sheet.cellAt('A4').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(7);
		});
		test('chained execution with passed data and loop element', async () => {
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet();
			machine.addStreamSheet(s3);
			// const monitorS2 = monitorStreamSheet(s2);
			s3.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE });
			s1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START });
			s2.updateSettings({ loop: { path: '[data]', enabled: true } });
			s3.updateSettings({ loop: { path: '[data]', enabled: true } });
			s1.sheet.loadCells({
				A1: { formula: 'A1+1' },
				A2: 'hello', B2: 'world',
				A3: { formula: 'execute("S2",2,array(A2,B2))' },
				A4: { formula: 'A4+1' }
			});
			s2.sheet.loadCells({
				B1: { formula: 'B1+1' },
				B2: 'john', C2: 'doe',
				B3: { formula: 'execute("S3", 3, array(B2,C2))' },
				B4: { formula: 'B4+1' }
			});
			s3.sheet.loadCells({ C1: { formula: 'C1+1' } });
			await machine.start();
			await wait(30);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(true);
			expect(s1.sheet.cellAt('A4').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			expect(s2.sheet.cellAt('B4').value).toBe(5);
			expect(s3.sheet.cellAt('C1').value).toBe(25);
		});
		test('one execution with passed data in "repeat until..." mode', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START });
			s2.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE, repeat: 'endless' });
			s1.sheet.loadCells({
				A1: { formula: 'A1+1' },
				A2: 'hello', B2: 'world',
				A3: { formula: 'execute("S2",3,array(A2,B2))' },
				A4: { formula: 'A4+1' }
			});
			s2.sheet.loadCells({ 
				B1: { formula: 'B1+1' },
				B2: { formula: 'if(mod(B1,4)=0,return(42),"waiting")'},
				B3: { formula: 'B3+1' } });
			await machine.start();
			await wait(30);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			expect(s2.sheet.cellAt('B2').value).toBe(42);
			expect(s2.sheet.cellAt('B3').value).toBe(9);
		});
		test('chained execution with passed data in "repeat until..." mode', async () => {
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet();
			machine.addStreamSheet(s3);
			s1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START });
			s2.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE, repeat: 'endless' });
			s3.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.EXECUTE, repeat: 'endless' });
			s1.sheet.loadCells({
				A1: { formula: 'A1+1' },
				A2: 'hello', B2: 'world',
				A3: { formula: 'execute("S2",2,array(A2,B2))' },
				A4: { formula: 'A4+1' }
			});
			s2.sheet.loadCells({ B1: { formula: 'B1+1' }, B2: { formula: 'execute("S3", 3)' } });
			s3.sheet.loadCells({ 
				C1: { formula: 'C1+1' },
				C2: { formula: 'if(mod(C1,4)=0,return(42),"waiting")'},
				C3: { formula: 'C3+1' } });
			await machine.start();
			await wait(30);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(true);
			// expect(s1.sheet.cellAt('A4').value).toBe(2);
			// expect(s2.sheet.cellAt('B1').value).toBe(3);
			// expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(12);
			expect(s3.sheet.cellAt('C3').value).toBe(9);
		});
	});
	describe.skip('executesteps counter', () => {
		it('should count each repetition in executesteps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(30);
			await machine.pause();
			expect(s2.stats.steps).toBe(4);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			await machine.stop();
		});
		it('should restart repetition count on each execution', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should restart repetition count on each repeat in "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",5)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,2)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.hasPassedStep(2);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			// 5x repetitions
			expect(s2.stats.steps).toBe(5);
			expect(s2.stats.executesteps).toBe(5);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.stop();
		});
		it('should increase step counter on each execution call', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s1.stats.steps).toBe(3);
			expect(s2.stats.steps).toBe(12);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should not increase step counter on each execution call on "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			expect(s2.stats.steps).toBe(1);
			expect(s2.stats.repeatsteps).toBeGreaterThan(2);
			expect(s2.stats.executesteps).toBe(1);
			await machine.stop();
		});
		it('should not count repeat steps in "repeat until..." mode if paused by function', async () => {
			const { machine, s2 } = setup();
			const t1 = new StreamSheet();
			t1.trigger = TriggerFactory.create({ type: TriggerFactory.TYPE.MACHINE_START });
			machine.addStreamSheet(t1);
			machine.cycletime = 50000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, t1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, t1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, t1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'pause(0.1)' }, s2.sheet);
			createCellAt('C2', { formula: 'C2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(500);
			expectValue(s2.stats.repeatsteps).toBeInRange(3, 6);
			await machine.stop(); // resumes execute...
			expect(t1.sheet.cellAt('A1').value).toBe(2);
			expect(t1.sheet.cellAt('A2').value).toBe(true);
			expect(t1.sheet.cellAt('A3').value).toBe(2); // because execute resumes on stop
			expectValue(s2.sheet.cellAt('B1').value).toBeInRange(3, 6);
			expectValue(s2.sheet.cellAt('C2').value).toBeInRange(3, 6);
			expectValue(s2.sheet.cellAt('B3').value).toBeInRange(3, 6);
		});
	});
	describe.skip('serialize', () => {
		it('should be possible to save trigger settings to JSON', () => {
			let json = new ExecuteTrigger().toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(ExecuteTrigger.TYPE);
			expect(json.repeat).toBe('once');
			json = new ExecuteTrigger({ repeat: 'endless' }).toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(ExecuteTrigger.TYPE);
			expect(json.repeat).toBe('endless');
		});
		it('should be possible to restore trigger from JSON', () => {
			let trigger = TriggerFactory.create(new ExecuteTrigger().toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(ExecuteTrigger.TYPE);
			expect(trigger.isEndless).toBe(false);
			trigger = TriggerFactory.create(new ExecuteTrigger({ repeat: 'endless' }).toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(ExecuteTrigger.TYPE);
			expect(trigger.isEndless).toBe(true);
		});
	});
});
