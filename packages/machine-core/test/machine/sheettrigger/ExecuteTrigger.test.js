/********************************************************************************
 * Copyright (c) 2020 Cedalo AG
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 ********************************************************************************/
const {
	ContinuouslyTrigger,
	ExecuteTrigger,
	Machine,
	Message,
	NeverTrigger,
	StreamSheet2,
	TriggerFactory
} = require('../../..');
const { createCellAt, monitorMachine, monitorStreamSheet, wait } = require('../../utils');

const addOutboxMessage = (machine, message) => {
	message = message || new Message({ outbox: true });
	machine.outbox.put(message);
	return message.id;
};

const setup = ({ switched = false } = {}) => {
	const machine = new Machine();
	const s1 = new StreamSheet2({ name: 'S1' });
	const s2 = new StreamSheet2({ name: 'S2' });
	s1.trigger = switched ? new ExecuteTrigger() : new ContinuouslyTrigger();
	s2.trigger = switched ? new ContinuouslyTrigger() : new ExecuteTrigger();
	machine.removeAllStreamSheets();
	machine.addStreamSheet(s1);
	machine.addStreamSheet(s2);
	machine.cycletime = 50;
	return { machine, s1, s2 };
};

describe('ExecuteTrigger', () => {
	describe('general behaviour', () => {
		it('should calculate sheet if called by another sheet on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should calculate sheet if called by another sheet on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should calculate sheet if called by another sheet on manual steps if machine is paused', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
		});
		it('should repeat execute as often as specified by repetitions parameter on manual step', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(5);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(13);
		});
		it('should repeat execute as often as specified by repetitions parameter on machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(13);
		});
		it('should pause calling sheet if execute with "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(5);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(3);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(4);
			expect(s2.sheet.cellAt('B3').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(9);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it.skip('should pause calling sheet until execute returns in "repeat until..." on manual steps switched sheet order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(false);
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(9);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it('should pause calling sheet until execute returns in "repeat until..." on machine run and switched order', async () => {
			const { machine, s1, s2 } = setup({ switched: true });
			s1.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'if(mod(A1,3)=0,return(),false)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'execute("S1")' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s2.sheet.cellAt('B3').value).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
		});
		it('should execute endlessly in "repeat until..." on manual step', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(5);
		});
		it('should execute endlessly in "repeat until..." on machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
		});
		it('should stop repetitions of execute as soon as return() is called with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(3);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(15);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it('should stop repetitions of execute as soon as return() is called with machine run', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it.skip('should stop repetitions of execute as soon as return() is called in "repeat until..." with manual steps', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(3);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(15);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		it('should stop repetitions of execute as soon as return() is called in "repeat until..." with machine run', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",10)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B3', { formula: 'if(mod(B2,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B3').value).toBe(true);
		});
		test('chain of execution with several sheets on machine run', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet2();
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(9);
			expect(s3.sheet.cellAt('C2').value).toBe(true);
			expect(s3.sheet.cellAt('C3').value).toBe(9);
		});
		test.skip('chain of execution with several sheets on manual steps', async () => {
			// CHAIN: S1 -> S3 -> S2
			const { machine, s1, s2 } = setup();
			const s3 = new StreamSheet2();
			machine.addStreamSheet(s3);
			s3.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S3")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('C1', { formula: 'C1+1' }, s3.sheet);
			createCellAt('C2', { formula: 'execute("S2")' }, s3.sheet);
			createCellAt('C3', { formula: 'C3+1' }, s3.sheet);
			createCellAt('C4', { formula: 'if(mod(C3,3)=0,return(),false)' }, s3.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(1);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(2);
			expect(s3.sheet.cellAt('C3').value).toBe(2);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(3);
			expect(s3.sheet.cellAt('C3').value).toBe(3);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(4);
			expect(s3.sheet.cellAt('C3').value).toBe(4);
			expect(s3.sheet.cellAt('C4').value).toBe(false);
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s3.sheet.cellAt('C1').value).toBe(6);
			expect(s3.sheet.cellAt('C3').value).toBe(6);
			expect(s3.sheet.cellAt('C4').value).toBe(true);
		});
	});
	describe('updating trigger', () => {
		it('should stop repeat "repeat until..." if corresponding setting is disabled', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger.update({ repeat: 'once' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it('should continue process sheet if new trigger is set', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new ExecuteTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThanOrEqual(3);
			await machine.stop();
		});
		it('should stop process sheet if new trigger is NONE', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			s2.trigger = new NeverTrigger();
			await wait(70);
			expect(s1.sheet.cellAt('A1').value).toBeGreaterThanOrEqual(3);
			expect(s1.sheet.cellAt('A3').value).toBeGreaterThanOrEqual(3);
			expect(s2.sheet.cellAt('B2').value).toBe(2);
			await machine.stop();
		});
		it('should stop "repeat until..." if new trigger is set without "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger();
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBe(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			await machine.stop();
		});
		it.skip('should keep "repeat until..." if new trigger is set with same', async () => {
			const { machine, s1, s2 } = setup();
			machine.cycletime = 5000;
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(2);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			const s2b2 = s2.sheet.cellAt('B2').value;
			await wait(20);
			expect(s2.sheet.cellAt('B2').value).toBeGreaterThan(s2b2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
		it('should not resume on "repeat until.." if new trigger is set and sheet is paused by function', async () => {
			const { machine, s1, s2 } = setup();
			const newTrigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'pause()' }, s2.sheet);
			createCellAt('B3', { formula: 'B3+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			s2.trigger = newTrigger;
			await wait(20);
			expect(s2.sheet.cellAt('B3').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			await machine.stop();
		});
	});
	describe('message processing', () => {
		it('should use passed message on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(1);
			await machine.step();
			await machine.step();
			expect(monitorS2.messages.attached).toBe(3);
			expect(monitorS2.messages.detached).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
		});
		it('should use passed message on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.stop();
			expect(monitorS2.messages.attached).toBe(2);
			expect(monitorS2.messages.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
		});
		it('should use passed message before using inbox ones', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(3);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			// a processed message is removed with next step
			await machine.step();
			expect(s2.inbox.size).toBe(1);
		});
		it('should use passed message before using inbox ones on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			const monitorS1 = monitorStreamSheet(s1);
			const machineMonitor = monitorMachine(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 3, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(20);
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s1.stats.steps).toBe(1);
			expect(s2.inbox.size).toBe(4);
			expect(s2.machine.outbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.start();
			await monitorS1.isAtStep(2);
			await machine.pause();
			expect(s1.stats.steps).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			// last used message is popped on next step
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s1.stats.steps).toBe(3);
			// last used message is popped on next step
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.start();
			await machineMonitor.nextSteps(2);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
		});
		it('should consume a message on each execute-repetition on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			// last message is consumed but still in inbox due to client...
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
		});
		it('should consume a message on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s1.stats.steps).toBe(2);
			expect(s2.stats.executesteps).toBe(3);
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(3);
			await machine.stop();
			expect(s2.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(16);
		});
		it('should consume loop-element on each repetition on manual steps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
		});
		it('should consume loop-element on each execute-repetition on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 3)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }, { val: 7 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			// processed message is consumed by next step, still in inbox due to client...
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should use passed message with loop element before next in inbox', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			expect(s2.inbox.size).toBe(3);
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			// increase repetitions value => inbox messages must be used:
			createCellAt('A2', { formula: `execute("S2", 5, "out:${messageId}")` }, s1.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
		});
		it('should use passed message with loop element before next in inbox on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const machineMonitor = monitorMachine(machine);
			const messageId = addOutboxMessage(machine, new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 2, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			s2.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }, { val: 6 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(3);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			// increase repetitions value => inbox messages must be used:
			createCellAt('A2', { formula: `execute("S2", 5, "out:${messageId}")` }, s1.sheet);
			await machine.start();
			await machineMonitor.nextSteps(1);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(10);
			await machine.stop();
		});
		it('should reuse passed message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			let messageId = addOutboxMessage(machine);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.step();
			expect(monitorS2.messages.attached).toBe(1);
			expect(monitorS2.messages.detached).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			messageId = addOutboxMessage(machine);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(monitorS2.messages.attached).toBe(2);
			expect(monitorS2.messages.detached).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
		});
		it('should reuse passed message on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const messageId = addOutboxMessage(machine);
			const monitorS2 = monitorStreamSheet(s2);
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2", 1, "out:${messageId}")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,2)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.isAtStep(4);
			await wait(10); // <-- give S2 time to return...
			await machine.stop();
			expect(s2.sheet.cellAt('B1').value).toBe(8);
			expect(monitorS2.messages.attached).toBe(4); // <-- executed 3x
			expect(monitorS2.messages.detached).toBe(4); // <-- 3 because we detach old message
			expect(s2.sheet.cellAt('B1').value).toBe(8);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
		});
		it('should reuse same message on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			s1.trigger = new ContinuouslyTrigger();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.trigger = new ExecuteTrigger({ repeat: 'endless' });
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A2', { formula: 'A2+1' }, s2.sheet);
			createCellAt('A3', { formula: 'if(mod(A2,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('A2').value).toBe(2);
			expect(s2.sheet.cellAt('A3').value).toBe(false);
			await machine.step();
			expect(s2.inbox.size).toBe(3); // <-- detach in next step
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('A2').value).toBe(3);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('A2').value).toBe(6);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
			await machine.step();
			expect(s2.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s2.inbox.size).toBe(1); // <-- keep last message
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('A2').value).toBe(9);
			expect(s2.sheet.cellAt('A3').value).toBe(true);
		});
		it('should reuse same message on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await machine.pause();
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			s2.inbox.put(new Message());
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			expect(s2.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(1);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(1);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.start();
			await monitorS2.isAtStep(1);
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.isAtStep(3);
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			await machine.stop();
		});
		it('should reuse same loop-element on "repeat until..." until return()', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 1)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s2.trigger.update({ repeat: 'endless' });
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }] }));
			s2.inbox.put(new Message());
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			expect(s2.inbox.size).toBe(4);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			expect(s2.sheet.cellAt('B2').value).toBe(false);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(2); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(1); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0);
			await machine.step();
			expect(s2.getLoopIndex()).toBe(0); // <-- next message is taken with next step
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			// we stay at last message and loop element
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(9);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
		});
		it('should reuse same loop-element on "repeat until..." until return() on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			s2.trigger.update({ repeat: 'endless' });
			s2.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await machine.pause();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2", 1)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			s2.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }, { val: 3 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 4 }, { val: 5 }] }));
			s2.inbox.put(new Message({ loop: [{ val: 6 }] }));
			s2.inbox.put(new Message());
			expect(s2.inbox.size).toBe(4);
			await machine.start();
			await monitorS2.isAtStep(2);
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(4);
			expect(s2.getLoopIndex()).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.isAtStep(4);
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(3);
			expect(s2.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.isAtStep(6);
			await wait(10);
			await machine.pause();
			expect(s2.inbox.size).toBe(2);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.start();
			await monitorS2.isAtStep(8);
			await wait(10);
			await machine.pause();
			// we stay at last message and loop element
			expect(s2.inbox.size).toBe(1);
			expect(s2.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(9);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(9);
			expect(s2.sheet.cellAt('B1').value).toBe(24);
			expect(s2.sheet.cellAt('B2').value).toBe(true);
			await machine.stop();
		});
		it('should resume calling sheet and stop "repeat until..." if execute() cell is replaced', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			// replace execute cell
			createCellAt('A2', { formula: 'A2+1' }, s1.sheet);
			await machine.step();
			expect(s1.stats.steps).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s1.sheet.cellAt('A2').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.stats.steps).toBe(5);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s1.sheet.cellAt('A2').value).toBe(5);
			expect(s1.sheet.cellAt('A3').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
		});
		it('should resume calling sheet and stop "repeat until..." if execute() cell is replaced on running machine', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS1 = monitorStreamSheet(s1);
			// const machineMonitor = monitorMachine(machine);
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: `execute("S2")` }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(10);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A3').value).toBe(1);
			expect(s2.sheet.cellAt('B1').value).toBeGreaterThanOrEqual(3);
			// replace execute cell
			createCellAt('A2', { formula: 'A2+1' }, s1.sheet);
			const s2b1 = s2.sheet.cellAt('B1').value;
			await machine.start();
			await monitorS1.isAtStep(4);
			await machine.pause();
			expect(s1.stats.steps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s1.sheet.cellAt('A2').value).toBe(4);
			expect(s1.sheet.cellAt('A3').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(s2b1);
			await machine.stop();
		});
		test('calling sheet waits at same message on "repeat until..." until execute() returns', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			await machine.step();
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(4);
			await machine.step();
			await machine.step();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.step();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			// stay at last message:
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
		});
		test('calling sheet waits at same message on "repeat until..." until execute() returns on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			await machine.start();
			await machine.pause();
			// setup sheets
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.isAtStep(1);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.isAtStep(2);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.start();
			await monitorS2.isAtStep(3);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			// stay at last message:
			await machine.start();
			await monitorS2.isAtStep(5);
			await wait(10);	// <-- give S2 some time to return
			await machine.stop();
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(6);
			expect(s2.sheet.cellAt('B1').value).toBe(15);
		});
		test('calling sheet waits at same loop-element on "repeat until..." until execute() returns', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s1.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(2);
			await machine.step();
			expect(s1.inbox.size).toBe(3);
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.step();
			await machine.step();
			await machine.step();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.inbox.size).toBe(3);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(7);
			await machine.step();
			await machine.step();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			await machine.step();
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			// stay at last message:
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			await machine.step();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(17);
		});
		test('calling sheet waits at same loop-element on "repeat until..." until execute() returns on machine run', async () => {
			const { machine, s1, s2 } = setup();
			const monitorS2 = monitorStreamSheet(s2);
			await machine.start();
			await machine.pause();
			// setup sheets
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2")' }, s1.sheet);
			s1.updateSettings({ loop: { path: '[data][loop]', enabled: true } });
			s1.inbox.put(new Message({ loop: [{ val: 1 }, { val: 2 }] }));
			s1.inbox.put(new Message({ loop: [{ val: 3 }] }));
			s1.inbox.put(new Message());
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			createCellAt('B2', { formula: 'if(mod(B1,3)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await monitorS2.isAtStep(1);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(2);
			expect(s2.sheet.cellAt('B1').value).toBe(3);
			await machine.start();
			await monitorS2.isAtStep(2);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.inbox.size).toBe(3);
			expect(s1.getLoopIndex()).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(3);
			expect(s2.sheet.cellAt('B1').value).toBe(6);
			await machine.start();
			await monitorS2.isAtStep(3);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			// message is popped of with next step!
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s2.sheet.cellAt('B1').value).toBe(9);
			await machine.start();
			await monitorS2.isAtStep(4);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(5);
			expect(s2.sheet.cellAt('B1').value).toBe(12);
			// stay at last message:
			await machine.start();
			await monitorS2.isAtStep(6);
			await wait(10);	// <-- give S2 some time to return
			await machine.pause();
			expect(s1.getLoopIndex()).toBe(0);
			expect(s1.inbox.size).toBe(1);
			expect(s1.sheet.cellAt('A1').value).toBe(7);
			expect(s2.sheet.cellAt('B1').value).toBe(18);
		});
	});
	describe('executesteps counter', () => {
		it('should count each repetition in executesteps', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(30);
			await machine.pause();
			expect(s2.stats.steps).toBe(1);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(5);
			await machine.stop();
		});
		it('should restart repetition count on each execution', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should restart repetition count on each repeat in "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'A1+1' }, s1.sheet);
			createCellAt('A2', { formula: 'execute("S2",5)' }, s1.sheet);
			createCellAt('A3', { formula: 'A3+1' }, s1.sheet);
			createCellAt('B2', { formula: 'B2+1' }, s2.sheet);
			createCellAt('B4', { formula: 'if(mod(B2,2)=0,return(),false)' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.stop();
			// executesteps count is bound by return each 2 calcs
			expect(s2.stats.executesteps).toBe(2);
			expect(s1.sheet.cellAt('A1').value).toBe(4);
			expect(s1.sheet.cellAt('A2').value).toBe(true);
			expect(s1.sheet.cellAt('A3').value).toBe(4);
			expect(s2.sheet.cellAt('B2').value).toBe(6);
			expect(s2.sheet.cellAt('B4').value).toBe(true);
		});
		it('should increase step counter on each execution call', async () => {
			const { machine, s1, s2 } = setup();
			createCellAt('A1', { formula: 'execute("S2", 4)' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(120);
			await machine.pause();
			expect(s1.stats.steps).toBe(3);
			expect(s2.stats.steps).toBe(3);
			expect(s2.stats.executesteps).toBe(4);
			expect(s1.sheet.cellAt('A1').value).toBe(true);
			expect(s2.sheet.cellAt('B1').value).toBe(13);
			await machine.stop();
		});
		it('should not increase step counter on each execution call on "repeat until..."', async () => {
			const { machine, s1, s2 } = setup();
			s2.trigger.update({ repeat: 'endless' });
			createCellAt('A1', { formula: 'execute("S2")' }, s1.sheet);
			createCellAt('B1', { formula: 'B1+1' }, s2.sheet);
			await machine.start();
			await wait(70);
			await machine.pause();
			expect(s1.stats.steps).toBe(1);
			expect(s2.stats.steps).toBe(1);
			expect(s2.stats.repeatsteps).toBeGreaterThan(2);
			expect(s2.stats.executesteps).toBe(1);
			await machine.stop();
		});
	});
	describe('serialize', () => {
		it('should be possible to save trigger settings to JSON', () => {
			let json = new ExecuteTrigger().toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(json.repeat).toBe('once');
			json = new ExecuteTrigger({ repeat: 'endless' }).toJSON();
			expect(json).toBeDefined();
			expect(json.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(json.repeat).toBe('endless');
		});
		it('should be possible to restore trigger from JSON', () => {
			let trigger = TriggerFactory.create(new ExecuteTrigger().toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(trigger.isEndless).toBe(false);
			trigger = TriggerFactory.create(new ExecuteTrigger({ repeat: 'endless' }).toJSON());
			expect(trigger).toBeDefined();
			expect(trigger.type).toBe(TriggerFactory.TYPE.EXECUTE);
			expect(trigger.isEndless).toBe(true);
		});
	});
});
